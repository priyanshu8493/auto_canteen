<!DOCTYPE html>
<html>
<head>
    <title>Meal Counter - Device 2</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
        }
        #count {
            font-size: 100px;
            margin: 20px;
            transition: all 0.5s ease;
        }
        .count-update {
            color: #28a745 !important;
            transform: scale(1.1);
        }
        button {
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 10px;
            background: white;
            color: black;
            cursor: pointer;
            margin: 10px;
        }
        .controls {
            margin-top: 20px;
        }
        #connection-status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        .connected {
            background-color: #28a745;
            color: white;
        }
        .disconnected {
            background-color: #dc3545;
            color: white;
        }
        .voice-status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #333;
        }
        .audio-controls {
            margin: 20px 0;
        }
        #visual-alert {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(40, 167, 69, 0.3);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .scan-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(40, 167, 69, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 1001;
            min-width: 500px;
            box-shadow: 0 0 40px rgba(40, 167, 69, 0.8);
            animation: popupSlideIn 0.3s ease;
        }
        @keyframes popupSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        @keyframes popupSlideOut {
            from {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            to {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
        }
        .device-indicator {
            position: absolute;
            top: 10px;
            right: 20px;
            background-color: #007bff;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
    </style>
    
    <!-- Preload audio elements -->
    <audio id="beep-sound" preload="auto">
        <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
    </audio>
    
    <script>
        // Audio context for better browser compatibility
        let audioContext = null;
        let voiceEnabled = true;
        let currentCount = {{ count }};
        let socket = null;
        let audioInitialized = false;

        // Initialize audio system
        function initAudio() {
            if (audioInitialized) return;
            audioInitialized = true;
            
            console.log('Initializing audio system (Device 2)...');
            console.log('Is secure context:', window.isSecureContext);
            console.log('Protocol:', window.location.protocol);
            console.log('Platform:', navigator.platform);
            console.log('User Agent:', navigator.userAgent);
            
            // Try to create audio context (required for some browsers)
            try {
                if (window.AudioContext || window.webkitAudioContext) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                    console.log('Audio context initialized successfully');
                    console.log('Audio context state:', audioContext.state);
                    console.log('Sample rate:', audioContext.sampleRate);
                    
                    // Resume audio context if suspended (crucial for Raspberry Pi)
                    if (audioContext.state === 'suspended') {
                        console.log('Audio context is suspended, will resume on user interaction');
                    }
                }
            } catch (e) {
                console.log('Audio context initialization failed:', e);
            }
            
            // Test if speech synthesis is available
            if (!('speechSynthesis' in window)) {
                console.log('Speech synthesis not available');
                voiceEnabled = false;
                updateVoiceStatus('Voice not supported in this browser');
                return;
            }
            
            console.log('Speech synthesis available, checking voices...');
            console.log('Current voices:', window.speechSynthesis.getVoices().length);
            
            // Check if speech synthesis is actually working
            // Try multiple times as voices may load asynchronously
            let voiceCheckCount = 0;
            const checkVoices = () => {
                voiceCheckCount++;
                const voices = speechSynthesis.getVoices();
                console.log(`Voice check ${voiceCheckCount}: ${voices.length} voices found`);
                
                if (voices.length === 0 && voiceCheckCount < 10) {
                    // Retry after a delay (increased from 5 to 10 attempts for Raspberry Pi)
                    setTimeout(checkVoices, 200);
                } else if (voices.length === 0) {
                    console.log('No voices available after multiple attempts');
                    voiceEnabled = false;
                    updateVoiceStatus('No voices - Using server TTS fallback');
                } else {
                    console.log('Voices loaded successfully:', voices.length);
                    console.log('Available voices:', voices.map(v => v.name).join(', '));
                    updateVoiceStatus('Voice ready - Click button to activate');
                }
            };
            
            checkVoices();
        }

        // Update voice status display
        function updateVoiceStatus(message) {
            const statusEl = document.getElementById('voice-status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // Simple beep sound as fallback
        function playBeep() {
            try {
                const beep = document.getElementById('beep-sound');
                if (beep) {
                    beep.volume = 0.5;
                    beep.play().catch(e => console.log('Beep play failed:', e));
                }
            } catch (e) {
                console.log('Beep error:', e);
            }
        }

        // Create beep using Web Audio API
        function playWebAudioBeep() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentYime + 0.5);
                
            } catch (e) {
                console.log('Web Audio beep failed:', e);
            }
        }

        // Speech synthesis with better error handling and Raspberry Pi support
        function speak(text) {
            if (!voiceEnabled) {
                console.log('Voice disabled, trying server TTS fallback...');
                speakViaAPI(text);
                return;
            }
            
            try {
                // Resume audio context if suspended (required for Raspberry Pi)
                if (audioContext && audioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context...');
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    }).catch(e => {
                        console.log('Failed to resume audio context:', e);
                    });
                }
                
                // Cancel any ongoing speech
                if (speechSynthesis.speaking) {
                    console.log('Canceling ongoing speech');
                    speechSynthesis.cancel();
                }
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.95; // Slightly slower for clarity
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                // Try to select a better voice
                const voices = speechSynthesis.getVoices();
                console.log('Available voices for synthesis:', voices.length);
                
                if (voices.length > 0) {
                    // Prefer English voices, then default
                    let selectedVoice = null;
                    
                    // Priority order for Raspberry Pi
                    const voicePriority = [
                        v => v.lang.startsWith('en-US'),
                        v => v.lang.startsWith('en'),
                        v => v.lang === 'en',
                        v => v.default,
                        v => true  // any voice
                    ];
                    
                    for (const priority of voicePriority) {
                        selectedVoice = voices.find(priority);
                        if (selectedVoice) break;
                    }
                    
                    utterance.voice = selectedVoice;
                    console.log('Selected voice:', selectedVoice ? selectedVoice.name : 'default');
                    console.log('Voice language:', selectedVoice ? selectedVoice.lang : 'default');
                } else {
                    console.log('WARNING: No voices found, speech may not work');
                }
                
                let speechStarted = false;
                
                utterance.onstart = function() {
                    console.log('Speech started:', text);
                    speechStarted = true;
                    updateVoiceStatus('Speaking...');
                };
                
                utterance.onend = function() {
                    console.log('Speech ended');
                    updateVoiceStatus('Voice ready');
                };
                
                utterance.onerror = function(event) {
                    console.log('Speech error:', event.error);
                    console.log('Error code:', event.error);
                    
                    if (!speechStarted) {
                        console.log('Browser speech never started, trying server TTS fallback...');
                        speakViaAPI(text);
                    }
                };
                
                console.log('Attempting browser speech synthesis for:', text);
                speechSynthesis.speak(utterance);
                
                // Fallback timeout: if speech doesn't start within 2 seconds, use server TTS
                setTimeout(() => {
                    if (!speechStarted && speechSynthesis.speaking === false) {
                        console.log('Browser speech did not start within timeout, using server TTS...');
                        speakViaAPI(text);
                    }
                }, 2000);
                
            } catch (error) {
                console.log('Speech synthesis failed:', error);
                console.log('Trying server TTS fallback...');
                // Try fallback TTS via API
                speakViaAPI(text);
            }
        }

        // Fallback: Use server-side TTS if browser speech fails
        function speakViaAPI(text) {
            console.log('Using server-side TTS fallback...');
            try {
                // Create audio element with explicit settings
                const audioElement = new Audio();
                audioElement.crossOrigin = 'anonymous';
                audioElement.preload = 'auto';
                audioElement.volume = 1.0;
                
                const ttsUrl = `{{ url_for('api_speak', _external=False) }}?text=${encodeURIComponent(text)}`;
                console.log('Fetching TTS from:', ttsUrl);
                
                audioElement.src = ttsUrl;
                
                // Set up event handlers
                audioElement.onloadstart = () => {
                    console.log('Server TTS: Loading started');
                };
                
                audioElement.oncanplay = () => {
                    console.log('Server TTS: Audio can play, duration:', audioElement.duration);
                };
                
                audioElement.onplay = () => {
                    console.log('Server TTS: Playback started');
                    updateVoiceStatus('Speaking (Server TTS)...');
                };
                
                audioElement.onended = () => {
                    console.log('Server TTS: Playback ended');
                    updateVoiceStatus('Voice ready');
                };
                
                audioElement.onerror = (e) => {
                    console.log('Server TTS: Playback error:', e);
                    console.log('Error code:', audioElement.error?.code);
                    console.log('Error message:', audioElement.error?.message);
                    console.log('All TTS methods failed, using visual alert only');
                    updateVoiceStatus('Voice unavailable - visual alerts only');
                    showVisualAlert();
                };
                
                // Try to play with explicit error handling
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('Server TTS playback initiated successfully');
                        updateVoiceStatus('Speaking (Server TTS)...');
                    }).catch(e => {
                        console.log('Server TTS play promise rejected:', e);
                        console.log('Error name:', e.name);
                        
                        // Try alternative approach: fetch audio and use Web Audio API
                        console.log('Attempting fallback via Web Audio API...');
                        fetch(ttsUrl)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                return response.arrayBuffer();
                            })
                            .then(arrayBuffer => {
                                if (!audioContext) {
                                    console.log('No audio context available for fallback');
                                    showVisualAlert();
                                    return;
                                }
                                
                                audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                                    const source = audioContext.createBufferSource();
                                    source.buffer = audioBuffer;
                                    source.connect(audioContext.destination);
                                    source.start();
                                    console.log('Web Audio API playback started');
                                    updateVoiceStatus('Speaking (Web Audio)...');
                                }, (e) => {
                                    console.log('Audio decode failed:', e);
                                    showVisualAlert();
                                });
                            })
                            .catch(e => {
                                console.log('Fallback fetch failed:', e);
                                showVisualAlert();
                            });
                    });
                }
            } catch (e) {
                console.log('Server TTS API call failed:', e);
                showVisualAlert();
            }
        }

        // Visual feedback for Raspberry Pi
        function showVisualAlert() {
            const visualAlert = document.getElementById('visual-alert');
            if (visualAlert) {
                visualAlert.style.opacity = '1';
                setTimeout(() => {
                    visualAlert.style.opacity = '0';
                }, 1000);
            }
        }

        // Show pop-up for scan with faculty name
        function showScanPopup(facultyName) {
            // Remove existing popup if any
            const existingPopup = document.querySelector('.scan-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup element
            const popup = document.createElement('div');
            popup.className = 'scan-popup';
            popup.textContent = 'âœ“ ' + facultyName;
            document.body.appendChild(popup);
            
            // Remove popup after 3 seconds
            setTimeout(() => {
                popup.style.animation = 'popupSlideOut 0.3s ease';
                setTimeout(() => {
                    popup.remove();
                }, 300);
            }, 3000);
        }

        // Update connection status
        function updateConnectionStatus(isConnected) {
            const statusEl = document.getElementById('connection-status');
            if (isConnected) {
                statusEl.textContent = 'ðŸŸ¢ Live - Connected to Device 2';
                statusEl.className = 'connected';
            } else {
                statusEl.textContent = 'ðŸ”´ Offline - No Connection';
                statusEl.className = 'disconnected';
            }
        }

        // Handle counter updates with multiple feedback methods
        function handleCounterUpdate(newCount) {
            const countElement = document.getElementById('count');
            const oldCount = currentCount;
            
            // Visual feedback
            countElement.classList.add('count-update');
            setTimeout(() => {
                countElement.classList.remove('count-update');
            }, 1000);
            
            // Only provide audio/voice feedback for increases
            if (newCount > oldCount) {
                const mealDifference = newCount - oldCount;
                let message = '';
                
                if (mealDifference === 1) {
                    message = "Meal served. Total: " + newCount;
                } else {
                    message = mealDifference + " meals. Total: " + newCount;
                }
                
                // Try voice first, then fallbacks
                speak(message);
                
                // Additional visual feedback
                showVisualAlert();
            } else if (newCount === 0 && oldCount > 0) {
                // Counter reset
                speak("Counter reset to zero");
                showVisualAlert();
            }
            
            currentCount = newCount;
            countElement.innerText = newCount;
        }

        // Refresh count from API
        async function refreshCount() {
            try {
                const res = await fetch("{{ url_for('api_counter2', _external=False) }}");
                const data = await res.json();
                handleCounterUpdate(data.count);
                updateConnectionStatus(true);
            } catch (error) {
                console.error('Error fetching count:', error);
                updateConnectionStatus(false);
            }
        }

        // Initialize Socket.IO for real-time updates
        function initializeSocketIO() {
            try {
                // Configure Socket.IO for reverse proxy environments
                // Compute base path (e.g. '/auto_canteen') from the current pathname to form correct socket.io path
                const pathParts = window.location.pathname.split('/').filter(p => p);
                const basePath = pathParts.length > 0 ? '/' + pathParts[0] : '';
                const socketPath = basePath + '/socket.io/';
                
                const socketConfig = {
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: Infinity,
                    // For Nginx reverse proxy with Cloudflare and Raspberry Pi
                    path: socketPath,
                    secure: window.location.protocol === 'https:',
                    rejectUnauthorized: false,
                    forceNew: true,
                    // Raspberry Pi specific settings
                    upgradeTimeout: 20000,
                    rememberUpgrade: true,
                    // Connect to device2 namespace
                    namespace: '/device2'
                };
                
                console.log('Initializing Socket.IO (Device 2) with config:', socketConfig);
                socket = io(socketConfig);
                
                socket.on('connect', function() {
                    console.log('Connected to server via Socket.IO (Device 2)');
                    console.log('Socket ID:', socket.id);
                    console.log('Connected with transport:', socket.io.engine.transport.name);
                    updateConnectionStatus(true);
                    // Only speak if voice is already enabled
                    if (voiceEnabled && audioInitialized) {
                        speak("Device two counter connected");
                    }
                });
                
                socket.on('disconnect', function(reason) {
                    console.log('Disconnected from server. Reason:', reason);
                    updateConnectionStatus(false);
                });
                
                socket.on('counter_update', function(data) {
                    console.log('Counter update received (Device 2):', data);
                    handleCounterUpdate(data.count);
                });
                
                socket.on('new_scan', function(scanData) {
                    console.log('New scan detected (Device 2):', scanData);
                    // Show pop-up alert with faculty name
                    if (scanData.faculty_name) {
                        showScanPopup(scanData.faculty_name);
                        // Speak the faculty name
                        const message = "Meal served to " + scanData.faculty_name;
                        speak(message);
                    }
                });
                
                socket.on('connect_error', function(error) {
                    console.log('Socket.IO connection error (Device 2):', error);
                    updateConnectionStatus(false);
                });
                
                socket.on('error', function(error) {
                    console.log('Socket.IO error (Device 2):', error);
                });
                
            } catch (error) {
                console.error('Socket.IO initialization error (Device 2):', error);
                updateConnectionStatus(false);
            }
        }

        // Reset counter with confirmation
        function resetCounter() {
            if (confirm('Are you sure you want to reset the Device 2 counter to zero?')) {
                if (voiceEnabled) {
                    speak("Device two counter reset to zero");
                }
                document.getElementById('reset-form').submit();
            }
        }

        // Manual voice test
        function testVoice() {
            if (voiceEnabled) {
                speak("Voice test. Device two counter system is working.");
            } else {
                playBeep();
                playWebAudioBeep();
                showVisualAlert();
                alert("Voice not available. Using alternative alerts.");
            }
        }

        // Enable audio on user interaction (required for autoplay)
        function enableAudio() {
            console.log('Enabling audio (Device 2)...');
            console.log('Audio context state:', audioContext ? audioContext.state : 'no context');
            console.log('Voice enabled:', voiceEnabled);
            console.log('Audio initialized:', audioInitialized);
            
            // Resume audio context if it exists and is suspended
            if (audioContext && audioContext.state === 'suspended') {
                console.log('Attempting to resume audio context...');
                audioContext.resume().then(() => {
                    console.log('âœ… Audio context resumed successfully');
                }).catch(e => {
                    console.log('âŒ Failed to resume audio context:', e);
                });
            }
            
            // Initialize if not done yet
            if (!audioInitialized) {
                console.log('Audio not initialized yet, running init...');
                initAudio();
            }
            
            // Test voice system - prefer server TTS on Raspberry Pi
            if (voiceEnabled && speechSynthesis.getVoices().length > 0) {
                console.log('Browser voice available, testing...');
                speak("Audio activated. Device two system ready for voice announcements.");
                updateVoiceStatus('Voice activated - System ready');
            } else {
                console.log('Browser voice not available, using server TTS for testing...');
                speakViaAPI("Audio activated. Device two system ready for voice announcements.");
                updateVoiceStatus('Server TTS activated - System ready');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Device 2 Counter page loaded');
            console.log('Browser capabilities:');
            console.log('  - Secure context:', window.isSecureContext);
            console.log('  - Protocol:', window.location.protocol);
            console.log('  - Speech Synthesis:', !!window.speechSynthesis);
            console.log('  - Web Audio API:', !!(window.AudioContext || window.webkitAudioContext));
            
            // Initialize audio systems
            initAudio();
            
            // Initialize with current count
            handleCounterUpdate({{ count }});
            
            // Set up periodic refresh (fallback if Socket.IO fails)
            setInterval(refreshCount, 5000);
            
            // Initialize Socket.IO for real-time updates
            initializeSocketIO();
            
            // Enable audio on first user interaction (required for autoplay in modern browsers)
            // Try multiple triggers for Raspberry Pi compatibility
            const enableAudioOnce = {once: true, passive: true};
            
            document.addEventListener('click', enableAudio, enableAudioOnce);
            document.addEventListener('touchstart', enableAudio, enableAudioOnce);
            document.addEventListener('keydown', enableAudio, enableAudioOnce);
            
            // Buttons event handlers
            const testVoiceBtn = document.getElementById('test-voice-btn');
            if (testVoiceBtn) {
                testVoiceBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Test voice button clicked');
                    testVoice();
                });
            }
            
            const enableAudioBtn = document.getElementById('enable-audio-btn');
            if (enableAudioBtn) {
                enableAudioBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Enable audio button clicked');
                    enableAudio();
                });
            }
            
            console.log('Device 2 Counter page initialization complete');
        });
    </script>
</head>
<body>
    <!-- Visual alert overlay -->
    <div id="visual-alert"></div>
    
    <div class="device-indicator">Device 2</div>
    
    <h1>Meal Counter - Device 2</h1>
    <div id="count">{{ count }}</div>
    
    <div class="voice-status" id="voice-status">
        Loading audio system...
    </div>
    
    <div class="audio-controls">
        <button id="enable-audio-btn">Enable Audio</button>
        <button id="test-voice-btn">Test Voice</button>
    </div>
    
    <div class="controls">
        <form id="reset-form" method="POST" action="{{ url_for('reset_counter2', _external=False) }}">
            <button type="button" onclick="resetCounter()">Reset Counter</button>
        </form>
    </div>
    
    <div id="connection-status" class="disconnected">
        ðŸ”´ Connecting...
    </div>

    <!-- Fallback script for older browsers -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
</body>
</html>
