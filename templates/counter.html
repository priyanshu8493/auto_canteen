<!DOCTYPE html>
<html>
<head>
    <title>Meal Counter</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
        }
        #count {
            font-size: 100px;
            margin: 20px;
            transition: all 0.5s ease;
        }
        .count-update {
            color: #28a745 !important;
            transform: scale(1.1);
        }
        button {
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 10px;
            background: white;
            color: black;
            cursor: pointer;
            margin: 10px;
        }
        .controls {
            margin-top: 20px;
        }
        #connection-status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        .connected {
            background-color: #28a745;
            color: white;
        }
        .disconnected {
            background-color: #dc3545;
            color: white;
        }
        .voice-status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #333;
        }
        .audio-controls {
            margin: 20px 0;
        }
        #visual-alert {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(40, 167, 69, 0.3);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
    </style>
    
    <!-- Preload audio elements -->
    <audio id="beep-sound" preload="auto">
        <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
    </audio>
    
    <script>
        // Audio context for better browser compatibility
        let audioContext = null;
        let voiceEnabled = true;
        let currentCount = {{ count }};
        let socket = null;
        let audioInitialized = false;

        // Initialize audio system
        function initAudio() {
            if (audioInitialized) return;
            audioInitialized = true;
            
            console.log('Initializing audio system...');
            console.log('Is secure context:', window.isSecureContext);
            console.log('Protocol:', window.location.protocol);
            
            // Try to create audio context (required for some browsers)
            try {
                if (window.AudioContext || window.webkitAudioContext) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                    console.log('Audio context initialized successfully');
                }
            } catch (e) {
                console.log('Audio context initialization failed:', e);
            }
            
            // Test if speech synthesis is available
            if (!('speechSynthesis' in window)) {
                console.log('Speech synthesis not available');
                voiceEnabled = false;
                updateVoiceStatus('Voice not supported in this browser');
                return;
            }
            
            console.log('Speech synthesis available, waiting for voices...');
            
            // Check if speech synthesis is actually working
            // Try multiple times as voices may load asynchronously
            let voiceCheckCount = 0;
            const checkVoices = () => {
                voiceCheckCount++;
                const voices = speechSynthesis.getVoices();
                console.log(`Voice check ${voiceCheckCount}: ${voices.length} voices found`);
                
                if (voices.length === 0 && voiceCheckCount < 5) {
                    // Retry after a delay
                    setTimeout(checkVoices, 500);
                } else if (voices.length === 0) {
                    console.log('No voices available after multiple attempts');
                    voiceEnabled = false;
                    updateVoiceStatus('No voice packages - Click button to enable');
                } else {
                    console.log('Voices loaded successfully:', voices.length);
                    updateVoiceStatus('Voice ready - Click button to activate');
                }
            };
            
            checkVoices();
        }

        // Update voice status display
        function updateVoiceStatus(message) {
            const statusEl = document.getElementById('voice-status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // Simple beep sound as fallback
        function playBeep() {
            try {
                const beep = document.getElementById('beep-sound');
                if (beep) {
                    beep.volume = 0.5;
                    beep.play().catch(e => console.log('Beep play failed:', e));
                }
            } catch (e) {
                console.log('Beep error:', e);
            }
        }

        // Create beep using Web Audio API
        function playWebAudioBeep() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                
            } catch (e) {
                console.log('Web Audio beep failed:', e);
            }
        }

        // Speech synthesis with better error handling and Raspberry Pi support
        function speak(text) {
            if (!voiceEnabled) {
                console.log('Voice disabled, using visual feedback only');
                showVisualAlert();
                return;
            }
            
            try {
                // Resume audio context if suspended (required for Raspberry Pi)
                if (audioContext && audioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context...');
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    }).catch(e => {
                        console.log('Failed to resume audio context:', e);
                    });
                }
                
                // Cancel any ongoing speech
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0; // Normal speed
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                // Try to select a better voice
                const voices = speechSynthesis.getVoices();
                console.log('Available voices for synthesis:', voices.length);
                
                if (voices.length > 0) {
                    // Prefer English voices
                    const enVoice = voices.find(voice => 
                        voice.lang.startsWith('en-') || voice.lang === 'en'
                    );
                    utterance.voice = enVoice || voices[0];
                    console.log('Selected voice:', utterance.voice ? utterance.voice.name : 'default');
                } else {
                    console.log('WARNING: No voices found, speech may not work');
                }
                
                utterance.onstart = function() {
                    console.log('Speech started:', text);
                    updateVoiceStatus('Speaking...');
                };
                
                utterance.onend = function() {
                    console.log('Speech ended');
                    updateVoiceStatus('Voice ready');
                };
                
                utterance.onerror = function(event) {
                    console.log('Speech error:', event.error);
                    console.log('Trying alternative TTS method...');
                    // Try fallback TTS via API
                    speakViaAPI(text);
                };
                
                speechSynthesis.speak(utterance);
                console.log('Speech synthesis initiated for:', text);
                
            } catch (error) {
                console.log('Speech synthesis failed:', error);
                console.log('Trying alternative TTS method...');
                // Try fallback TTS via API
                speakViaAPI(text);
            }
        }

        // Fallback: Use server-side TTS if browser speech fails
        function speakViaAPI(text) {
            console.log('Using server-side TTS fallback...');
            try {
                const audioElement = new Audio();
                const ttsUrl = `{{ url_for('api_speak', _external=False) }}?text=${encodeURIComponent(text)}`;
                audioElement.src = ttsUrl;
                audioElement.play().then(() => {
                    console.log('Server TTS playback started');
                    updateVoiceStatus('Speaking (Server TTS)...');
                }).catch(e => {
                    console.log('Server TTS playback failed:', e);
                    console.log('All TTS methods failed, using visual alert only');
                    updateVoiceStatus('Voice unavailable - visual alerts only');
                    showVisualAlert();
                });
            } catch (e) {
                console.log('Server TTS API call failed:', e);
                showVisualAlert();
            }
        }

        // Visual feedback for Raspberry Pi
        function showVisualAlert() {
            const visualAlert = document.getElementById('visual-alert');
            if (visualAlert) {
                visualAlert.style.opacity = '1';
                setTimeout(() => {
                    visualAlert.style.opacity = '0';
                }, 1000);
            }
        }

        // Update connection status
        function updateConnectionStatus(isConnected) {
            const statusEl = document.getElementById('connection-status');
            if (isConnected) {
                statusEl.textContent = 'ðŸŸ¢ Live - Connected to Dashboard';
                statusEl.className = 'connected';
            } else {
                statusEl.textContent = 'ðŸ”´ Offline - No Connection';
                statusEl.className = 'disconnected';
            }
        }

        // Handle counter updates with multiple feedback methods
        function handleCounterUpdate(newCount) {
            const countElement = document.getElementById('count');
            const oldCount = currentCount;
            
            // Visual feedback
            countElement.classList.add('count-update');
            setTimeout(() => {
                countElement.classList.remove('count-update');
            }, 1000);
            
            // Only provide audio/voice feedback for increases
            if (newCount > oldCount) {
                const mealDifference = newCount - oldCount;
                let message = '';
                
                if (mealDifference === 1) {
                    message = "Meal served. Total: " + newCount;
                } else {
                    message = mealDifference + " meals. Total: " + newCount;
                }
                
                // Try voice first, then fallbacks
                speak(message);
                
                // Additional visual feedback
                showVisualAlert();
            } else if (newCount === 0 && oldCount > 0) {
                // Counter reset
                speak("Counter reset to zero");
                showVisualAlert();
            }
            
            currentCount = newCount;
            countElement.innerText = newCount;
        }

        // Refresh count from API
        async function refreshCount() {
            try {
                const res = await fetch("{{ url_for('api_counter', _external=False) }}");
                const data = await res.json();
                handleCounterUpdate(data.count);
                updateConnectionStatus(true);
            } catch (error) {
                console.error('Error fetching count:', error);
                updateConnectionStatus(false);
            }
        }

        // Initialize Socket.IO for real-time updates
        function initializeSocketIO() {
            try {
                // Configure Socket.IO for reverse proxy environments
                const socketConfig = {
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: Infinity,
                    // For Nginx reverse proxy with Cloudflare
                    path: window.location.pathname + 'socket.io/',
                    secure: window.location.protocol === 'https:',
                    rejectUnauthorized: false
                };
                
                console.log('Initializing Socket.IO with config:', socketConfig);
                socket = io(socketConfig);
                
                socket.on('connect', function() {
                    console.log('Connected to server via Socket.IO');
                    updateConnectionStatus(true);
                    // Only speak if voice is already enabled
                    if (voiceEnabled && audioInitialized) {
                        speak("Counter connected");
                    }
                });
                
                socket.on('disconnect', function() {
                    console.log('Disconnected from server');
                    updateConnectionStatus(false);
                });
                
                socket.on('counter_update', function(data) {
                    console.log('Counter update received:', data);
                    handleCounterUpdate(data.count);
                });
                
                socket.on('new_scan', function(scanData) {
                    console.log('New scan detected:', scanData);
                });
                
                socket.on('connect_error', function(error) {
                    console.log('Socket.IO connection error:', error);
                    updateConnectionStatus(false);
                });
                
            } catch (error) {
                console.error('Socket.IO initialization error:', error);
                updateConnectionStatus(false);
            }
        }

        // Reset counter with confirmation
        function resetCounter() {
            if (confirm('Are you sure you want to reset the counter to zero?')) {
                if (voiceEnabled) {
                    speak("Counter reset to zero");
                }
                document.getElementById('reset-form').submit();
            }
        }

        // Manual voice test
        function testVoice() {
            if (voiceEnabled) {
                speak("Voice test. Counter system is working.");
            } else {
                playBeep();
                playWebAudioBeep();
                showVisualAlert();
                alert("Voice not available. Using alternative alerts.");
            }
        }

        // Enable audio on user interaction (required for autoplay)
        function enableAudio() {
            console.log('Enabling audio...');
            console.log('Audio context state:', audioContext ? audioContext.state : 'no context');
            
            // Resume audio context if it exists and is suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Audio context resumed successfully');
                }).catch(e => {
                    console.log('Failed to resume audio context:', e);
                });
            }
            
            // Initialize if not done yet
            if (!audioInitialized) {
                initAudio();
            }
            
            // Test voice system
            if (voiceEnabled) {
                speak("Audio activated. System ready for voice announcements.");
                updateVoiceStatus('Voice activated - System ready');
            } else {
                console.log('Voice not available, using fallback alerts');
                playBeep();
                playWebAudioBeep();
                showVisualAlert();
                updateVoiceStatus('Voice not available - Using visual alerts');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Counter page loaded');
            console.log('Browser capabilities:');
            console.log('  - Secure context:', window.isSecureContext);
            console.log('  - Protocol:', window.location.protocol);
            console.log('  - Speech Synthesis:', !!window.speechSynthesis);
            console.log('  - Web Audio API:', !!(window.AudioContext || window.webkitAudioContext));
            
            // Initialize audio systems
            initAudio();
            
            // Initialize with current count
            handleCounterUpdate({{ count }});
            
            // Set up periodic refresh (fallback if Socket.IO fails)
            setInterval(refreshCount, 5000);
            
            // Initialize Socket.IO for real-time updates
            initializeSocketIO();
            
            // Enable audio on first user interaction (required for autoplay in modern browsers)
            // Try multiple triggers for Raspberry Pi compatibility
            const enableAudioOnce = {once: true, passive: true};
            
            document.addEventListener('click', enableAudio, enableAudioOnce);
            document.addEventListener('touchstart', enableAudio, enableAudioOnce);
            document.addEventListener('keydown', enableAudio, enableAudioOnce);
            
            // Buttons event handlers
            const testVoiceBtn = document.getElementById('test-voice-btn');
            if (testVoiceBtn) {
                testVoiceBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Test voice button clicked');
                    testVoice();
                });
            }
            
            const enableAudioBtn = document.getElementById('enable-audio-btn');
            if (enableAudioBtn) {
                enableAudioBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Enable audio button clicked');
                    enableAudio();
                });
            }
            
            console.log('Counter page initialization complete');
        });
    </script>
</head>
<body>
    <!-- Visual alert overlay -->
    <div id="visual-alert"></div>
    
    <h1>Meal Counter</h1>
    <div id="count">{{ count }}</div>
    
    <div class="voice-status" id="voice-status">
        Loading audio system...
    </div>
    
    <div class="audio-controls">
        <button id="enable-audio-btn">Enable Audio</button>
        <button id="test-voice-btn">Test Voice</button>
    </div>
    
    <div class="controls">
        <form id="reset-form" method="POST" action="{{ url_for('reset_counter', _external=False) }}">
            <button type="button" onclick="resetCounter()">Reset Counter</button>
        </form>
    </div>
    
    <div id="connection-status" class="disconnected">
        ðŸ”´ Connecting...
    </div>

    <!-- Fallback script for older browsers -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
</body>
</html>
